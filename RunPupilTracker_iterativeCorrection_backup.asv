function [] = RunPupilTracker_iterativeCorrection_backup(procDataFileIDs)
%________________________________________________________________________________________________________________________
% Written by Kyle W. Gheres & Kevin L. Turner
% The Pennsylvania State University, Dept. of Biomedical Engineering
% https://github.com/KL-Turner
%________________________________________________________________________________________________________________________
%
%   Purpose: Track changes in pupil area and detect periods of blinking
%________________________________________________________________________________________________________________________


% create/load pre-existing ROI file with the coordinates
ROIFileDir = dir('*_PupilData.mat');
if isempty(ROIFileDir) == true
    PupilData = [];
    PupilData.EyeROI = [];
else
    ROIFileName = {ROIFileDir.name}';
    ROIFileID = char(ROIFileName);
    load(ROIFileID);
end
if isfield(PupilData,'firstFileOfDay') == false
    % establish the number of unique days based on file IDs
    [~,fileDates,~] = GetFileInfo_IOS(procDataFileIDs);
    [uniqueDays,~,DayID] = GetUniqueDays_IOS(fileDates);
    for aa = 1:length(uniqueDays)
        strDay = ConvertDate_IOS(uniqueDays{aa,1});
        FileInd = DayID == aa;
        dayFilenames.(strDay) = procDataFileIDs(FileInd,:);
    end
    for bb = 1:length(uniqueDays)
        strDay = ConvertDate_IOS(uniqueDays{bb,1});
        for cc = 1:size(dayFilenames.(strDay),1)
            procDataFileID = dayFilenames.(strDay)(cc,:);
            load(procDataFileID)
            [animalID,~,fileID] = GetFileInfo_IOS(procDataFileID);
            pupilCamFileID = [fileID '_PupilCam.bin'];
            fid = fopen(pupilCamFileID); % reads the binary file in to the work space
            fseek(fid,0,'eof'); % find the end of the video frame
            imageHeight = ProcData.notes.pupilCamPixelHeight; %#ok<*NODEF>
            imageWidth = ProcData.notes.pupilCamPixelWidth;
            pixelsPerFrame = imageWidth*imageHeight;
            skippedPixels = pixelsPerFrame;
            roiImage = zeros(imageHeight,imageWidth,1);
            fseek(fid,1*skippedPixels,'bof'); % read .bin File to roiImage
            z = fread(fid,pixelsPerFrame,'*uint8','b');
            img = reshape(z(1:pixelsPerFrame),imageWidth,imageHeight);
            roiImage(:,:,1) = flip(imrotate(img,-90),2);
            roiImage = uint8(roiImage); % convert double floating point data to unsignned 8bit integers
            workingImg{cc,1} = imcomplement(roiImage); % grab frame from image stack
        end
        desiredFig = figure;
        if length(workingImg) > 25
            workingImg = workingImg(1:25,1);
        end
        for dd = 1:length(workingImg)
            subplot(5,5,dd)
            imagesc(workingImg{dd,1})
            axis image
            axis off
            colormap gray
            title(['Session ' num2str(dd)])
        end
        % choose desired file
        desiredFile = input('Which file looks best for ROI drawing: '); disp(' ')
        PupilData.firstFileOfDay{1,bb} = dayFilenames.(strDay)(desiredFile,:);
        % resize image if larger than 200x200
        if ProcData.notes.pupilCamPixelHeight > 200
            newROI = [1,1,199,199];
            newROIFig = figure;
            imagesc(workingImg{desiredFile,1})
            axis image
            axis off
            colormap gray
            h = imrect(gca,newROI); %#ok<IMRECT>
            addNewPositionCallback(h,@(p) title(mat2str(p,3)));
            fcn = makeConstrainToRectFcn('imrect',get(gca,'XLim'),get(gca,'YLim'));
            setPositionConstraintFcn(h,fcn)
            position = wait(h);
            newImage = imcrop(workingImg{desiredFile,1},position);
            newImageFig = figure;
            imagesc(newImage)
            axis image
            axis off
            colormap gray
            PupilData.resizePosition{1,bb} = position;
            close(newROIFig)
            close(newImageFig)
        end
        clear workingImg
        close(desiredFig)
    end
    firstFileOfDay = PupilData.firstFileOfDay;
    save([animalID '_PupilData.mat'],'PupilData');
else
    firstFileOfDay = PupilData.firstFileOfDay;
end
% Create the desired window ROI for each day if it doesn't yet exist
for bb = 1:length(firstFileOfDay)
    firstFile = firstFileOfDay{1,bb};
    load(firstFile)
    [animalID,fileDate,fileID] = GetFileInfo_IOS(firstFile);
    strDay = ConvertDate_IOS(fileDate);
    if ~isfield(PupilData.EyeROI,(strDay))
        pupilCamFileID = [fileID '_PupilCam.bin'];
        fid = fopen(pupilCamFileID); % reads the binary file in to the work space
        fseek(fid,0,'eof'); % find the end of the video frame
        imageHeight = ProcData.notes.pupilCamPixelHeight; %#ok<*NODEF>
        imageWidth = ProcData.notes.pupilCamPixelWidth;
        pixelsPerFrame = imageWidth*imageHeight;
        skippedPixels = pixelsPerFrame;
        roiImage = zeros(imageHeight,imageWidth,1);
        fseek(fid,1*skippedPixels,'bof'); % read .bin File to roiImage
        z = fread(fid,pixelsPerFrame,'*uint8','b');
        img = reshape(z(1:pixelsPerFrame),imageWidth,imageHeight);
        roiImage(:,:,1) = flip(imrotate(img,-90),2);
        roiImage = uint8(roiImage); % convert double floating point data to unsignned 8bit integers
        if isfield(PupilData,'resizePosition') == true
            roiImage = imcrop(roiImage,PupilData.resizePosition{1,bb});
        end
        workingImg = imcomplement(roiImage); % grab frame from image stack
        disp('Draw roi around eye'); disp(' ')
        eyeFigure = figure;
        title('Draw ROI around eye')
        [eyeROI] = roipoly(workingImg);
        % model the distribution of pixel intensities as a gaussian to estimate/isolate the population of pupil pixels
        pupilHistEdges = 1:1:256; % camera data is unsigned 8bit integers. Ignore 0 values
        threshSet = 4.5; % StD beyond mean intensity to binarize image for pupil tracking
        medFiltParams = [5,5]; % [x,y] dimensions for 2d median filter of images
        filtImg = medfilt2(workingImg,medFiltParams); % median filter image
        threshImg = uint8(double(filtImg).*eyeROI); % only look at pixel values in ROI
        [phat,~] = mle(reshape(threshImg(threshImg ~= 0),1,numel(threshImg(threshImg ~= 0))),'distribution','Normal');
        % figure for verifying pupil threshold
        pupilROIFig = figure;
        subplot(1,3,1)
        pupilHist = histogram(threshImg((threshImg ~= 0)),'BinEdges',pupilHistEdges,'probability');
        xlabel('Pixel intensities');
        ylabel('Bin Counts');
        title('Histogram of image pixel intensities')
        normCounts = pupilHist.BinCounts./sum(pupilHist.BinCounts); % normalizes bin count to total bin counts
        theFit = pdf('normal',pupilHist.BinEdges,phat(1),phat(2)); % generate distribution from mle fit of data
        normFit = theFit./sum(theFit); % normalize fit so sum of gaussian ==1
        intensityThresh = phat(1) + (threshSet*phat(2)); % set threshold as 4.5 sigma above population mean estimated from MLE
        testImg = threshImg;
        testImg(threshImg >= intensityThresh) = 1;
        testImg(threshImg < intensityThresh) = 0;
        testThresh = labeloverlay(roiImage(:,:,1),testImg);
        axis square
        subplot(1,3,2)
        plot(pupilHist.BinEdges(2:end),normCounts,'k','LineWidth',1);
        xlabel('Pixel intensities');
        ylabel('Normalized bin counts');
        title('Normalized histogram and MLE fit of histogram');
        hold on;
        plot(pupilHist.BinEdges,normFit,'r','LineWidth',2);
        xline(intensityThresh,'--c','LineWidth',1);
        legend({'Normalized Bin Counts','MLE fit of data','Pixel intensity threshold'},'Location','northwest');
        xlim([0,256]);
        axis square
        subplot(1,3,3)
        imshow(testThresh);
        title('Pixels above threshold');
        % check threshold
        threshOK = false;
        manualPupilThreshold = [];
        while threshOK == false
            disp(['Intensity threshold: ' num2str(intensityThresh)]); disp (' ')
            threshCheck = input('Is pupil threshold value ok? (y/n): ','s'); disp(' ')
            if strcmp(threshCheck,'y') == true
                threshOK = true;
            else
                intensityThresh = input('Manually set pupil intensity threshold: '); disp(' ')
                testImg(threshImg >= intensityThresh) = 1;
                testImg(threshImg < intensityThresh) = 0;
                testThresh = labeloverlay(roiImage(:,:,1),testImg);
                manualPupilThreshold = figure;
                imshow(testThresh);
                title('Pixels above threshold');
            end
        end
        % save the file to directory.
        [pathstr,~,~] = fileparts(cd);
        dirpath = [pathstr '/Figures/Pupil ROI/'];
        if ~exist(dirpath,'dir')
            mkdir(dirpath);
        end
        savefig(eyeFigure,[dirpath fileID '_PupilROI'])
        savefig(pupilROIFig,[dirpath fileID '_PupilThreshold'])
        if isempty(manualPupilThreshold) == false
            savefig(manualPupilThreshold,[dirpath fileID '_ManualPupilThreshold'])
        end
        close all
        PupilData.EyeROI.(strDay) = eyeROI;
        PupilData.Threshold.(strDay) = intensityThresh;
        save([animalID '_PupilData.mat'],'PupilData');
    end
end
% run pupil/blink tracking on all data files
for cc = 1:size(procDataFileIDs,1)
    clearvars -except procDataFileIDs PupilData cc
    procDataFileID = procDataFileIDs(cc,:);
    load(procDataFileID)
    disp(['Checking pupil tracking status of file (' num2str(cc) '/' num2str(size(procDataFileIDs,1)) ')']); disp(' ')
    %     if isfield(ProcData.data,'Pupil') == false
    [animalID,fileDate,fileID] = GetFileInfo_IOS(procDataFileID);
    strDay = ConvertDate_IOS(fileDate);
    pupilCamFileID = [fileID '_PupilCam.bin'];
    idx = 0;
    for qq = 1:size(PupilData.firstFileOfDay,2)
        if strfind(PupilData.firstFileOfDay{1,qq},fileDate) >= 5
            idx = qq;
        end
    end
    % run pupil/blink tracking on all data files
    theAngles = 1:1:180; % projection angles measured during radon transform of pupil
    radonThresh = 0.05; % arbitrary threshold used to clean up radon transform above values == 1 below == 0
    pupilThresh = 0.25; % arbitrary threshold used to clean up inverse radon transform above values == 1 below == 0
    blinkThresh = 0.35; % arbitrary threshold used to binarize data for blink detection above values == 1 below == 0
    medFiltParams = [5,5]; % [x,y] dimensions for 2d median filter of images
    fid = fopen(pupilCamFileID); % reads the binary file in to the work space
    fseek(fid,0,'eof'); % find the end of the video frame
    fileSize = ftell(fid); % calculate file size
    fseek(fid,0,'bof'); % find the begining of video frames
    imageHeight = ProcData.notes.pupilCamPixelHeight; % how many pixels tall is the frame
    imageWidth = ProcData.notes.pupilCamPixelWidth; % how many pixels wide is the frame
    samplingRate = ProcData.notes.pupilCamSamplingRate;
    pixelsPerFrame = imageWidth*imageHeight;
    skippedPixels = pixelsPerFrame;
    nFramesToRead = floor(fileSize/(pixelsPerFrame));
    imageStack = zeros(200,200,nFramesToRead);
    % read .bin file to imageStack
    % read .bin file to imageStack
    for dd = 1:nFramesToRead
        fseek(fid,(dd - 1)*skippedPixels,'bof');
        z = fread(fid,pixelsPerFrame,'*uint8','b');
        img = reshape(z(1:pixelsPerFrame),imageWidth,imageHeight);
        if isfield(PupilData,'resizePosition') == true
            imageStack(:,:,dd) = imcrop(flip(imrotate(img,-90),2),PupilData.resizePosition{1,idx});
        else
            imageStack(:,:,dd) = flip(imrotate(img,-90),2);
        end
    end
    % convert double floating point data to unsignned 8bit integers
    imageStack = uint8(imageStack);
    % grab frame from image stack
    workingImg = imcomplement(imageStack(:,:,2));
    ProcData.data.Pupil.firstFrame = imageStack(:,:,2);
    % pre-allocate empty structures
    pupilArea(1:size(imageStack,3)) = NaN; % area of pupil
    pupilMajor(1:size(imageStack,3)) = NaN; % length of major axis of pupil
    pupilMinor(1:size(imageStack,3)) = NaN; % length of minor axis of pupil
    pupilCentroid(1:size(imageStack,3),2) = NaN; % center of pupil
    pupilBoundary(1:size(imageStack,1),1:size(imageStack,2),1:size(imageStack,3)) = NaN;
    % select ROI containing pupil
    eyeROI = PupilData.EyeROI.(strDay);
    % select pupil intensity threshold
    intensityThresh = PupilData.Threshold.(strDay);
    procStart = tic;
    disp(['Running pupil tracker for: ' pupilCamFileID]); disp(' ')
    imageFrames = gpuArray(imageStack);
    roiInt(1:size(imageFrames,3)) = NaN;
    roiInt = gpuArray(roiInt);
    correctedFlag=false;
    last_frame_ok = 1;
    for frameNum = 1:size(imageStack,3)
        filtImg = medfilt2(imcomplement(imageFrames(:,:,frameNum)),medFiltParams);
        % only look at pixel values in ROI
        threshImg = uint8(double(filtImg).*eyeROI);
        roiInt_temp = sum(threshImg,1);
        roiInt(frameNum) = sum(roiInt_temp,2);
        isoPupil = threshImg;
        isoPupil(isoPupil < intensityThresh) = 0;
        isoPupil(isoPupil >= intensityThresh) = 1;
        %isoPupil = medfilt2(isoPupil,medFiltParams); Removed median filter KWG
        radPupil = radon(isoPupil);
        minPupil = min(radPupil,[],1);
        minMat = repmat(minPupil,size(radPupil,1),1);
        maxMat = repmat(max((radPupil - minMat),[],1),size(radPupil,1),1);
        %normalize each projection angle to its min and max values. Each value should now be between [0 1]
        normPupil = (radPupil - minMat)./maxMat;
        threshPupil = normPupil;
        % binarize radon projection
        threshPupil(normPupil >= radonThresh) = 1;
        threshPupil(normPupil < radonThresh) = 0;
        %transform back to image space
        radonPupil = gather(iradon(double(threshPupil),theAngles,'linear','Hamming',size(workingImg,2)));
        if frameNum == 1
            saveRadonImg = radonPupil;
        end
        % find area corresponding to pupil on binary image
        [~,pupilBoundaries,objNum,adjacency] = bwboundaries(radonPupil >pupilThresh*max(radonPupil(:)),8,'noholes');
        % [~,pupilBoundaries,objNum,adjacency] = bwboundaries(gather(isoPupil),8,'noholes');
        if objNum==1
            fillPupil = pupilBoundaries;
            % fill any subthreshold pixels inside the pupil boundary
            fillPupil = imfill(fillPupil,8,'holes');
            areaFilled = regionprops(fillPupil,'FilledArea','Image','FilledImage','Centroid','MajorAxisLength','MinorAxisLength');
        else
            areaFilled = regionprops(pupilBoundaries,'FilledArea','Image','FilledImage','Centroid','MajorAxisLength','MinorAxisLength');
        end
        if frameNum > 1
            if abs((roiInt(frameNum) - roiInt(frameNum - 1))/roiInt(frameNum)) >= blinkThresh % Exclude fitting frame during blinks
                areaFilled = [];
                fillPupil(:) = 0;
            end
        end
        if ~isempty(areaFilled) %Is an pupil identified
            if size(areaFilled,1) > 1 %Is the pupil fragmented in to multiple ROI
                clear theArea areaLogical
                for num = 1:size(areaFilled,1)
                    theArea(num) = areaFilled(num).FilledArea; %#ok<*SAGROW>
                end
                maxArea = max(theArea);%Find the ROI with the largest area
                areaLogical = theArea == maxArea;
                areaFilled = areaFilled(areaLogical);
                areaFilled = areaFilled(1);
                % check for aberrant pupil diameter changes
                if frameNum > 1
                    fracChange = (maxArea - pupilArea(frameNum-1))/pupilArea(frameNum-1); %frame-wise fractional change
                    volFlag = fracChange <- 0.1; % does the change exceed a 10% reduction in pupil size
                    if ~isnan(pupilArea(frameNum - 1)) %does the current frame follow a blink
                        if volFlag==true
                            if correctedFlag==false
                                last_frame_ok=frameNum-1;
                                correctedFlag=true;
                            end
                            % correct aberrant diameters by altering radon threshold
                            pupilSweep = intensityThresh - (1:100); %adjust threshold of binary image instead of radon image KWG
                            for sweepNum = 1:size(pupilSweep,2)
                                if volFlag == true
                                    isoSweep = threshImg; % get video frame
                                    isoSweep(isoSweep < pupilSweep(sweepNum)) = 0; %set all pixel intensities below thresh to zero
                                    isoSweep(isoSweep>= pupilSweep(sweepNum)) = 1; %set all pixel intensities above thresh to one
                                    inPupil=[];
                                    [~,correctBoundaries,regionNum] = bwboundaries(gather(isoSweep),8,'noholes'); %Get above threshold regions
                                    fillCorrection = correctBoundaries;
                                    fillCorrection =imfill(fillCorrection,8,'holes'); %fill holes in regions
                                    areaCorrect = regionprops(fillCorrection,'FilledArea','Image','FilledImage','Centroid','MajorAxisLength','MinorAxisLength','PixelList'); %find region properties
                                    for areaNum=1:size(areaCorrect,1)
                                        areaCentroid=round(areaCorrect(areaNum).Centroid,0);
                                        inPupil(areaNum)=pupilBoundary(areaCentroid(2),areaCentroid(1),last_frame_ok); %determine if centroid of region was in previous pupil volume
                                    end
                                    theInds=find(inPupil==1);
                                    keepRegions=areaCorrect(theInds); %keep only regions within previous pupil measurements
                                    keepMask=zeros(size(fillCorrection,1),size(fillCorrection,2));
                                    for keepNum=1:size(keepRegions,1)
                                        for pixNum=1:size(keepRegions(keepNum).PixelList)
                                            keepMask(keepRegions(keepNum).PixelList(pixNum,2),keepRegions(keepNum).PixelList(pixNum,1))=1; %remap kept regions
                                        end
                                    end
                                    fuseMask=bwconvhull(keepMask); %use convex hull operation to enclose regions previously within pupil
                                    fusedCorrect = regionprops(fuseMask,'FilledArea','Image','FilledImage','Centroid','MajorAxisLength','MinorAxisLength','PixelList'); %measure new corrected pupil volume
                                    if ~isempty(fusedCorrect)
                                        fracChange = (fusedCorrect.FilledArea - pupilArea(last_frame_ok))/pupilArea(last_frame_ok);
                                        volFlag = fracChange < -0.1;
                                    else
                                        fracChange=100; % if no data present force frac change outside threshold to keep frame
                                    end
                                end
                            end
                            % this can be used to insert NaN if the change is > 10%
                            if  abs(fracChange) < 0.1 %changed to only fill data withing a +/- 10% change in area
                                %    fillPupil(:) = 0;
                                %    areaFilled.FilledArea = NaN;
                                %    areaFilled.MajorAxisLength = NaN;
                                %    areaFilled.MinorAxisLength = NaN;
                                %    areaFilled.Centroid = [NaN,NaN];
                                %else
                                fillPupil = fuseMask;
                                areaFilled = fusedCorrect;
                            end
                            if ~exist('correctedFrames','var')
                                frameInd = 1;
                                correctedFrames(frameInd) = frameNum;
                            else
                                frameInd = frameInd + 1;
                                correctedFrames(frameInd) = frameNum;
                            end
                        else
                            correctedFlag=false;
                            last_frame_ok=frameNum;
                        end
                    end
                end
            else
                if frameNum > 1
                    % check for aberrant pupil diameter changes
                    fracChange = (areaFilled.FilledArea - pupilArea(frameNum-1))/pupilArea(frameNum-1);
                    volFlag = fracChange < -0.1;
                    if ~isnan(pupilArea(frameNum - 1))
                        if volFlag==true
                            if correctedFlag==false
                                last_frame_ok=frameNum-1;
                                correctedFlag=true;
                            end
                            % correct aberrant diameters with previous pupil
                            % locations
                            pupilSweep = intensityThresh - (1:100); %adjust threshold of binary image instead of radon image KWG
                            for sweepNum = 1:size(pupilSweep,2)
                                if volFlag == true
                                    isoSweep = threshImg; % get video frame
                                    isoSweep(isoSweep < pupilSweep(sweepNum)) = 0; % set all pixel intensities below thresh to zero
                                    isoSweep(isoSweep>= pupilSweep(sweepNum)) = 1; % set all pixel intensities above thresh to one
                                    radSweep = radon(isoSweep); %take radon transform of binarized image
                                    minPupil = min(radSweep,[],1);
                                    minMat = repmat(minPupil,size(radSweep,1),1);
                                    maxMat = repmat(max((radSweep - minMat),[],1),size(radSweep,1),1);
                                    %normalize each projection angle to its min and max values. Each value should now be between [0 1]
                                    normSweep = (radSweep - minMat)./maxMat;
                                    threshSweep = normSweep;
                                    %binarize radon projection
                                    threshSweep(normSweep >= radonThresh) = 1;
                                    threshSweep(normSweep < radonThresh) = 0;
                                    %transform back to image space
                                    radonSweep = gather(iradon(double(threshSweep),theAngles,'linear','Hamming',size(workingImg,2)));
                                    sweepArea = [];
                                    [~,sweepBoundaries] = bwboundaries(radonSweep > pupilSweep(sweepNum)*max(radonSweep(:)),8,'noholes');
                                    fillSweep = sweepBoundaries;
                                    fillSweep = imfill(fillSweep,8,'holes');
                                    areaSweep = regionprops(fillSweep,'FilledArea','Image','FilledImage','Centroid','MajorAxisLength','MinorAxisLength');
                                    for num = 1:size(areaSweep,1)
                                        sweepArea(num) = areaSweep(num).FilledArea; %#ok<*AGROW>
                                    end
                                    maxSweep = max(sweepArea);
                                    sweepLogical = sweepArea == maxSweep;
                                    fracChange = (maxSweep - pupilArea(last_frame_ok))/pupilArea(last_frame_ok);
                                    volFlag = fracChange < -0.1;
                                end
                            end
                            % this can be used to insert NaN if the change is > 10%
                            if abs(fracChange) < 0.1
                                %    fillPupil(:) = 0;
                                %    areaFilled.FilledArea = NaN;
                                %    areaFilled.MajorAxisLength = NaN;
                                %    areaFilled.MinorAxisLength = NaN;
                                %    areaFilled.Centroid = [NaN,NaN];
                                % else
                                fillPupil = fillCorrection;
                                areaFilled = areaCorrect(sweepLogical);
                            end
                            if ~exist('correctedFrames','var')
                                frameInd = 1;
                                correctedFrames(frameInd)=frameNum;
                            else
                                frameInd = frameInd + 1;
                                correctedFrames(frameInd) = frameNum;
                            end
                        else
                            correctedFlag=false;
                            last_frame_ok=frameNum;
                        end
                    end
                end
            end
            pupilArea(frameNum) = areaFilled.FilledArea;
            pupilMajor(frameNum) = areaFilled.MajorAxisLength;
            pupilMinor(frameNum) = areaFilled.MinorAxisLength;
            pupilCentroid(frameNum,:) = areaFilled.Centroid;
            pupilBoundary(:,:,frameNum) = fillPupil;
            holdMat = labeloverlay(imageStack(:,:,frameNum),fillPupil,'Transparency',0.8);
            if size(holdMat,3) == 1
                overlay(:,:,:,frameNum) = repmat(holdMat,1,1,3);
            else
                overlay(:,:,:,frameNum) = holdMat;
            end
        else
            pupilArea(frameNum) = NaN;
            pupilMajor(frameNum) = NaN;
            pupilMinor(frameNum) = NaN;
            pupilCentroid(frameNum,:) = NaN;
            pupilBoundary(:,:,frameNum) = fillPupil;
            holdMat = labeloverlay(imageStack(:,:,frameNum),fillPupil);
            if size(holdMat,3) == 1
                overlay(:,:,:,frameNum) = repmat(holdMat,1,1,3);
            else
                overlay(:,:,:,frameNum) = holdMat;
            end
        end
    end
    ProcData.data.Pupil.rawPupilArea = pupilArea;
    ProcData.data.Pupil.pupilMajor = pupilMajor;
    ProcData.data.Pupil.pupilMinor = pupilMinor;
    ProcData.data.Pupil.pupilCentroid = pupilCentroid;
    ProcData.data.Pupil.eyeROI = eyeROI;
    ProcData.data.Pupil.roiIntensity = gather(roiInt);
    proceEnd = toc(procStart);
    procMin = proceEnd/60;
    minText = num2str(procMin);
    procSec = round(str2double(minText(2:end))*60,0);
    secText = num2str(procSec);
    disp(['File processing time: ' minText(1) ' min ' secText ' seconds']); disp(' ')
    blinks = find((abs(diff(ProcData.data.Pupil.roiIntensity))./ProcData.data.Pupil.roiIntensity(2:end)) >= blinkThresh) + 1;
    ProcData.data.Pupil.blinkFrames = overlay(:,:,:,blinks);
    ProcData.data.Pupil.blinkInds = blinks;
    % patch NaNs
    ProcData.data.Pupil.nanPupilPatch = fillmissing(data.pupilArea,'movmedian',31);
    % patch sudden spikes
    diffArea = abs(diff(data.nanPupilPatch));
    % threshold for interpolation
    threshold = 500;
    diffIndex = diffArea > threshold;
    [linkedDiffIndex] = LinkBinaryEvents(gt(diffIndex,0),[30,0]);
    edgeFound = false;
    % identify edges for interpolation
    xx = 1;
    for aa = 1:length(linkedDiffIndex)
        if edgeFound == false
            if linkedDiffIndex(1,aa) == 1
                startEdge(xx,1) = aa;
                edgeFound = true;
            end
        elseif edgeFound == true
            if linkedDiffIndex(1,aa) == 0
                endEdge(xx,1) = aa;
                xx = xx + 1;
                edgeFound = false;
            end
        end
    end
    % fill from start:ending edges of rapid pupil fluctuations that weren't NaN
    nanPupilArea = pupilArea;
    for aa = 1:length(startEdge)
        startTime = startEdge(aa,1);
        endTime = endEdge(aa,1);
        nanPupilArea(startTime:endTime) = NaN;
        data.patchedPupilArea = fillmissing(nanPupilArea,'spline');
    end
    % subplot for eye ROI
    figure
    subplot(2,2,1)
    imagesc(workingImg)
    hold on;
    x1 = plot(x12,y12,'color','r','LineWidth',1');
    title('ROI to measure changes in pupil area')
    legend(x1,'eye ROI')
    colormap gray
    axis image
    axis off
    % subplot for ROI histrogram and threshold
    subplot(2,2,2)
    pupilHist = histogram(threshImg((threshImg ~= 0)),'BinEdges',pupilHistEdges,'Normalization','Probability');
    theFit = pdf('normal',pupilHist.BinEdges,phat(1),phat(2)); % generate distribution from mle fit of data
    normFit = theFit./sum(theFit); % normalize fit so sum of gaussian ==1
    hold on;
    plot(pupilHist.BinEdges,normFit,'r','LineWidth',2);
    xline(intensityThresh,'--c','LineWidth',1);
    title('Histogram of image pixel intensities')
    xlabel('Pixel intensities');
    ylabel('Bin Counts');
    legend({'Normalized Bin Counts','MLE fit of data','Pupil intensity threshold'},'Location','northwest');
    xlim([0,256]);
    axis square
    % subplot for radon transform
    subplot(2,2,3)
    imagesc(saveRadonImg)
    title('Radon transform back to image space')
    colormap gray
    axis image
    axis off
    % subplot for measured pupil area
    subplot(2,2,4)
    imagesc(overlay(:,:,:,1));
    title('Calculated pupil area')
    colormap gray
    axis image
    % patch falsely rapid transitions
    figure
    sgtitle('Pupil area changes');
    subplot(2,1,1)
    hold on;
    nanVals = isnan(data.pupilArea);
    nanInds = find(nanVals == 1);
    for aa = 1:length(nanInds)
        x1 = xline(nanInds(1,aa)/samplingRate,'g');
    end
    difInds = find(diffIndex == 1);
    for bb = 1:length(difInds)
        x2 = xline(difInds(1,bb)/samplingRate,'b');
    end
    p1 = plot((1:length(data.pupilArea))/samplingRate,data.pupilArea,'k','LineWidth',1);
    xlabel('Time (sec)');
    ylabel('Pupil area (pixels)');
    legend([p1,x1,x2],'Original pupil area','ROI loss','ROI inaccuracy');
    set(gca,'box','off')
    axis tight
    subplot(2,1,2)
    plot((1:length(data.patchedPupilArea))/samplingRate,medfilt1(data.patchedPupilArea,7),'k','LineWidth',1);
    xlabel('Time (sec)');
    ylabel('Pupil area (pixels)');
    legend('Patched & medfilt pupil area');
    set(gca,'box','off')
    axis tight
    % end
end

end
